#include "xbus.h"
#include "cc430x513x.h"
#include "RF1A.h"
#include "squeue.h"
#include "stddef.h"
#include "adc.h"

#ifndef XB_ID
#error "XB_ID must be defined - use -DXB_ID=<ID> on GCC command line "
#endif

#define _XB_MAXPKTLEN  XB_MAXPKTLEN

const int SIZE_TD = sizeof(XB_MSG_TIMEDATE);

#define  CRC_OK             (BIT7)          // CRC_OK bit 
#define  PATABLE_VAL        (0x51)          // 0 dBm output 
extern RF_SETTINGS rfSettings;
static unsigned char RFRXCSUM,RFRXRSSI,HUBRSSI,HUBLQI;



void xbus_clear_stats();
unsigned char GetRF1ASTATB(void);
void xb_receive_ack(void);

typedef struct __attribute__ ((packed)){
  uint32 rx_pkts;
  uint32 tx_acks;
  uint32 tx_pkts;
  uint16 rx_crc_errs;
  uint16 rx_net_errs;
  uint16 tx_fails;
  uint16 tx_retries;
  uint16 tx_no_eop; 
  uint16 rx_overruns;
  uint16 rx_unexp_ack;
  uint16 tick_err;
  uint16 fatal;
  uint16 txn[4];
} XB_STATS;


typedef struct  __attribute__ ((packed)){
 uint8  pkt_len;
 uint8 dest;
 XB_MSG_HDR hdr;
 XB_MSG_TIMEDATE td; 
  uint8 xdata[64+2];  // RSSI and CRC appended
} XB_RX_BUFF  ;
static volatile XB_RX_BUFF _xb_rx_buff;


typedef struct  __attribute__ ((packed)) {
 uint8  pkt_len;
 uint8 dest;
 XB_MSG_HDR hdr;
 XB_MSG_TIMEDATE td; 
 uint8 xdata[64];  
} XB_TB_BUFF;



static volatile XB_TB_BUFF _xb_tx_buff;

typedef struct  __attribute__ ((packed)){
  uint8  pkt_len;
  uint8 dest;
  XB_MSG_HDR hdr;
  XB_MSG_TIMEDATE td; 
} XB_ACK_BUFF;

typedef struct  __attribute__ ((packed)){
  uint8  pkt_len;
  uint8 dest;
  XB_MSG_HDR hdr;
  XB_MSG_TIMEDATE td; 
  uint8 ack_data[sizeof(XB_STATS)];
} XB_FULLACK_BUFF;



static volatile XB_FULLACK_BUFF _xb_ack_buff;
//static volatile uint8 ack_data[sizeof(XB_STATS)];  // enough to take stats

static unsigned char rx_buffer_Length = 0;
typedef enum {
  XB_ST_IDLE,
  XB_ST_TX,
  XB_ST_WAITACK,
  XB_ST_CHKACK,
  XB_ST_RX,
  XB_ST_ACKDELAY,
  XB_ST_ACK,
} XB_STATE;

static volatile XB_STATE _xb_state ;
static const uint8 XBUS_ID=XB_ID;
static const uint8 XBUS_NET=XB_NET;
static uint8 _xb_tx_count;

#define XB_MAX_DEVICES 32

static uint8 _wakeup_list[XB_MAX_DEVICES];


static XB_STATS  _xb_stats;
volatile static XB_TX_STATUS _tx_status;
#define _XB_RXQ_DEPTH 4

/* new squeue implementation */

SQUEUE _xb_rx_q;
static uint8 _xb_rx_q_buff[_XB_RXQ_DEPTH * _XB_MAXPKTLEN];
static uint8 _xb_rx_q_blen[_XB_RXQ_DEPTH];


// temp debug
static volatile int _rx_push_cnt,_rx_pop_cnt;
static int pop_err,push_err;
static uint8 _xb_tick_enable;

#ifdef XB_MON_ID
uint8 _xb_mon_last_msgid;
#endif

// info structure

static const XB_DEVICEINFO info  = {XBDEVNAME , SVN };

const XB_DEVICEINFO *xb_info(){
  return &info;

}

static void  _xb_ps0_disable(){
  _xb_tick_enable = 0;
#ifndef XB_HUB
  if((xq_tx_data_avail() == 0) && xbus_can_sleep())
    rtc_ps0_disable();
#endif
}

static void  _xb_ps0_enable(VFUNCPTR func){
  _xb_tick_enable = 1;
#ifndef XB_HUB
  rtc_ps0_enable(func);
#endif
}


void xbus_start_tick(){
  rtc_ps0_enable(_xb_tick);

}

static uint8  _xb_can_sleep;

uint8 xbus_can_sleep(void){

#ifdef XB_HUB
  return 0;
#else
  return _xb_can_sleep ;
#endif
}



int  _rx_queue_push(){
#ifdef XB_UART
  return xq_utx_push((uint8 *)(&_xb_rx_buff),_xb_rx_buff.pkt_len+1+2); // include RSSI and LQI
#else
  return xq_app_push((uint8 *)(&_xb_rx_buff),_xb_rx_buff.pkt_len+1+2);
#endif
}
int  _rx_queue_full(){
#ifdef XB_UART
  return xq_utx_full();
#else
  return xq_app_full();
#endif
} 

void _response_clrstats(){
  xbus_clear_stats();
  _xb_ack_buff.pkt_len=sizeof(XB_ACK_BUFF) - 1; // len field not included in length

}

void _response_getstats(){
  int i;
  uint8 *statsptr = (uint8 *)&_xb_stats;
  uint8 *destptr = (uint8 *)&_xb_ack_buff.td; // td not used for stats reporting
  _xb_ack_buff.pkt_len=sizeof(XB_ACK_BUFF)  +sizeof(XB_STATS) - 1; // len field not included in length
  for ( i = 0 ; i < sizeof(XB_STATS) ; i++){
    destptr[i] = statsptr[i];
    //_xb_ack_buff.ack_data[i] = statsptr[i];
  }
  // _xb_tx_ack();    
}
void _response_gettime(){
  _xb_ack_buff.pkt_len=sizeof(XB_ACK_BUFF) + sizeof(XB_MSG_TIMEDATE) - 1; // len field not included in length
  rtc_get((TIMEDATE *) &_xb_ack_buff.td);
}
void _response_settime(){
  _xb_ack_buff.pkt_len=sizeof(XB_ACK_BUFF) - 1; // len field not included in length
  rtc_set((TIMEDATE *)&_xb_rx_buff.td);
}


void _response_ping(){
  _xb_ack_buff.pkt_len=sizeof(XB_ACK_BUFF) - 1; // len field not included in length
  // _xb_tx_ack();    
}

void _response_info(){

  int i;
  uint8 *statsptr = (uint8 *)&info;
  uint8 *destptr = (uint8 *)&_xb_ack_buff.td; // td not used for stats reporting
  _xb_ack_buff.pkt_len=sizeof(XB_ACK_BUFF)  +sizeof(XB_DEVICEINFO) - 1; // len field not included in length
  for ( i = 0 ; i < sizeof(XB_STATS) ; i++){
    destptr[i] = statsptr[i];
    //_xb_ack_buff.ack_data[i] = statsptr[i];
  }
 
}

void _response_sleep(){
  _xb_can_sleep = 1;
  _xb_ack_buff.pkt_len=sizeof(XB_ACK_BUFF) - 1; // len field not included in length
  // _xb_tx_ack();    
}
void _response_adc1(){
  _xb_ack_buff.pkt_len=sizeof(XB_ACK_BUFF) - 1; // len field not included in length
  // _xb_tx_ack();  
  adc_temp(1);
}
void _response_adc2(){
  _xb_ack_buff.pkt_len=sizeof(XB_ACK_BUFF) - 1; // len field not included in length
  // _xb_tx_ack();  
  adc_supply(1);
}



VFUNCPTR  _rx_immediate_response() { // see if rx message can be replied immediately
  switch (_xb_rx_buff.hdr.type){
    //case XB_PKT_PING: return _response_ping;  
#ifndef XB_HUB
  case XB_PKT_CLRSTATS: return _response_clrstats;
  case XB_PKT_GETSTATS: return _response_getstats;
  case XB_PKT_GETTIME: return _response_gettime;
  case XB_PKT_SETTIME: return _response_settime;
  case XB_PKT_SLEEP: return _response_sleep;  
  case XB_PKT_SENDADC1: return _response_adc1;  
  case XB_PKT_SENDADC2: return _response_adc2;         
  case XB_PKT_INFO: return _response_info;    
#endif     
  default:  return (VFUNCPTR)0;
  }

}

static volatile unsigned int _xb_tick_count,  _xb_htick_count;

void _xb_tick();
  


#define XB_ACK_MAXWAIT 3
#define XB_MAX_RETRIES 3

int _xb_ack_timer;
int _xb_retry_counter;
int _xb_retry_total;
int _xb_tx_fails;

// temp debug
uint8 RF1CTL1,RSTAT;
void _dbg99(){

}
void _xb_st_waitack(){
  xb_receive_ack();


  _xb_state = XB_ST_WAITACK;
  _xb_ps0_disable();

  _xb_tick_count = 0;
  RSTAT = GetRF1ASTATB();

  _xb_ps0_enable(_xb_tick);
  _dbg99();

}

int _xb_receiving(XB_STATE xbs){
  switch(xbs)
    {
    case XB_ST_RX: return 1;
    case XB_ST_WAITACK: return 1;
    default: return 0;
    }
  return 0;
}

int _xb_transmitting(XB_STATE xbs){
  switch(xbs)
    {
    case XB_ST_TX: return 1;
    case XB_ST_ACK: return 1;
    default: return 0;
    }
  return 0;
}

//transmit buffer
/*
static uint8 __attribute__ ((aligned (2))) _xb_tx_buff.pkt_len;
static uint8 _xb_tx_buff.dest;
static XB_MSG_HDR _xb_tx_buff.hdr;
static XB_MSG_TIMEDATE _xb_tx_buff.td; 
static uint8 _xb_tx_buff.buff[64];  
*/

void xb_active_on_lpm3(void){
  // Set the High-Power Mode Request Enable bit so LPM3 can be entered
  // with active radio enabled 
  PMMCTL0_H = 0xA5;
  PMMCTL0_L |= PMMHPMRE_L; 
  PMMCTL0_H = 0x00; 
}


void _xb_init_radio(void)
{
  // xb_active_on_lpm3();
  WriteRfSettings(&rfSettings);
  
  WriteSinglePATable(PATABLE_VAL);

}

int xbus_is_idle(){
  return _xb_tx_rdy() && !xq_tx_data_avail();
}

void _xb_receive_enable(void){
  RF1AIES |= BIT9;                          // Falling edge of RFIFG9
  RF1AIFG &= ~BIT9;                         // Clear a pending interrupt
  RF1AIE  |= BIT9;                          // Enable the interrupt 
  
  // Radio is in IDLE following a TX, so strobe SRX to enter Receive Mode
  // _xb_state = XB_ST_RX;
  // Strobe( RF_SFRX  );    
  Strobe( RF_SIDLE );
  Strobe( RF_SRX );      
}

void xb_receive_on(void)
{  

  _xb_state = XB_ST_RX;
  _xb_receive_enable();
           
}

void xb_receive_ack(void)
{  

  _xb_state = XB_ST_WAITACK;
  RF1AIES |= BIT9;                          // Falling edge of RFIFG9
  RF1AIFG &= ~BIT9;                         // Clear a pending interrupt
  RF1AIE  |= BIT9;                          // Enable the interrupt 
  
  // Radio is in IDLE following a TX, so strobe SRX to enter Receive Mode
  // _xb_state = XB_ST_RX;
  // Strobe( RF_SFRX  );    
  Strobe(RF_SIDLE );
  Strobe(RF_SFRX);
  Strobe(RF_SRX );                      
}


void xb_receive_off(void)
{
  RF1AIE &= ~BIT9;                          // Disable RX interrupts
  RF1AIFG &= ~BIT9;                         // Clear pending IFG

  // It is possible that ReceiveOff is called while radio is receiving a packet.
  // Therefore, it is necessary to flush the RX FIFO after issuing IDLE strobe 
  // such that the RXFIFO is empty prior to receiving a packet.
  Strobe( RF_SIDLE );
  Strobe( RF_SFRX  );    
  _xb_state = XB_ST_IDLE;
                 
}
// *****************************************************************************
// @fn          ResetRadioCore
// @brief       Reset the radio core using RF_SRES command
// @param       none
// @return      none
// *****************************************************************************
unsigned char RfRxStat(void){
  return Strobe(RF_RXSTAT | RF_SNOP);    
}
unsigned char RfTxStat(void){
  return Strobe(RF_TXSTAT | RF_SNOP);    
}



unsigned char GetRF1ASTATB(void){
 return Strobe(RF_SNOP);    
}

int _TIMEXXX;
uint8 _STATXXX;

uint8 xbus_copy_stats(uint8 *buffer){
  uint8 i;
  uint8 *ptr = (uint8 *)&_xb_stats;
  for ( i = 0 ; i < sizeof(XB_STATS) ; i++){
    buffer[i] = ptr[i];
  }
  return i;

}
void xbus_clear_stats(){
  int i;
  uint8 *ptr = (uint8 *)&_xb_stats;
  for ( i = 0 ; i < sizeof(XB_STATS) ; i++){
    ptr[i] = 0;
  }

  /*
  _xb_stats.rx_pkts = 0;
  _xb_stats.tx_pkts = 0;
  _xb_stats.rx_crc_errs = 0;
  _xb_stats.tx_fails = 0;
  _xb_stats.tx_retries = 0;
  _xb_stats.rx_overruns = 0;
  _xb_stats.rx_unexp_ack = 0;
  */
}

uint8 xbus_copy_info(uint8 *buffer){
  uint8 i;
  uint8 *ptr = (uint8 *)&info;
  for ( i = 0 ; i < sizeof(XB_DEVICEINFO) ; i++){
    buffer[i] = ptr[i];
  }
  return i;

}
static volatile int  _rf_isr_cnt,_setup_ack_cnt,_tx_ack_cnt;

void _xbus_idle(){
  _xb_state = XB_ST_IDLE;
  Strobe( RF_SIDLE );

}




static uint8 _xb_device_is_awake(uint8 device){
  int i;
  for ( i = 0 ; i < XB_MAX_DEVICES ; i++){
    if(_wakeup_list[i] == device)   
      return 1;
  }
  return 0;
}

void xb_sleep_device(uint8 device){
  int i;
  for ( i = 0 ; i < XB_MAX_DEVICES ; i++){
    if(_wakeup_list[i] == device){      
      _wakeup_list[i] = 0;
      break;
    }
  }  
}

void xb_wake_device(uint8 device){
  int i;

  if (_xb_device_is_awake(device))
    return;
  for ( i = 0 ; i < XB_MAX_DEVICES ; i++){
    if(_wakeup_list[i] == 0){      
      _wakeup_list[i] = device;
      break;
    }
  }  
}


void xbus_init(){

  int i;
  for ( i = 0 ; i < XB_MAX_DEVICES ; i++){
    _wakeup_list[i] = 0;

  }
  _xb_state = XB_ST_IDLE;
  _xb_retry_total = 0; 
  _xb_tx_fails = 0; 
  // init tx buff constants
  _xb_tx_buff.hdr.netid = XB_NET;
  _xb_tx_buff.hdr.source = XB_ID;     
  _xb_tx_buff.hdr.msgid = 0;
  // init ack buff
  _xb_ack_buff.pkt_len=sizeof(XB_ACK_BUFF) - 1; // len field not included in length
  _xb_ack_buff.hdr.netid = XB_NET;
  _xb_ack_buff.hdr.source = XB_ID;     
  _xb_ack_buff.hdr.type = 0;
 
  // init stats
  xbus_clear_stats();

  // init q
  xqueues_init();
  // setup RTC PSO
  rtc_init();


  _xb_tick_count = 0;
  _xb_htick_count = 0;
  rtc_ps0_init(DIV32,_xb_tick);  // 1KHz tick
  _xb_tick_enable = 0;


#ifdef XB_UART
  uart_init();
#endif

#ifdef XB_MON_ID
  _xb_mon_last_msgid = 0;
#endif 
  // debug vars
  _rf_isr_cnt = 0;
  _setup_ack_cnt = 0;
  _tx_ack_cnt = 0;
  ResetRadioCore();
  _xb_init_radio();
 
#ifdef XB_HUB
  // hub needs continous tick
  rtc_ps0_enable(_xb_tick);
#endif

}


int  _xb_setup_ack(){  // have short turn round delay before tx
  _xb_ps0_disable();
  _xb_state = XB_ST_ACKDELAY;

  _setup_ack_cnt++;
  Strobe( RF_SIDLE );
  Strobe( RF_SFTX  );    
  Strobe( RF_SFRX  );  
  
  _xb_tick_count = 0;
  _xb_ps0_enable(_xb_tick);


}

int  _xb_tx_ack(){
  _tx_ack_cnt++;
  _xb_ack_buff.hdr.msgid = _xb_rx_buff.hdr.msgid;  // ack returns received msgid 
  _xb_ack_buff.dest = _xb_rx_buff.hdr.source;  // send ack to source 
  _xb_ack_buff.hdr.rssi = RFRXRSSI; 
  _xb_ack_buff.hdr.lqi = RFRXCSUM & 0x7f; 

  RF1AIES |= BIT9;                          
  RF1AIFG &= ~BIT9;                         // Clear pending interrupts
  RF1AIE |= BIT9;                           // Enable TX end-of-packet interrupt  
  
  //Strobe( RF_STX );                         // Strobe STX   
  Strobe( RF_SIDLE );
  Strobe( RF_SFTX  );  
  Strobe( RF_SNOP );                         // Strobe STX   
  
  WriteBurstReg(RF_TXFIFOWR, (uint8 *)&_xb_ack_buff,_xb_ack_buff.pkt_len + 1);     
  Strobe( RF_STX );                         // Strobe STX   
  return 0; 
}

// this is ugly 
uint8 _xbus_msg_xdata_len(uint8 type){
  switch(type){
  case XB_PKT_ACK: return 0;
  case XB_PKT_PING: return 0 ;
  case XB_PKT_SETTIME: return 0 ;
  case XB_PKT_GETTIME: return 0;
  case XB_PKT_TEMP: return sizeof(XB_MSG_TEMP) ;
  case XB_PKT_INFO: return sizeof(XB_DEVICEINFO) ;
  case XB_PKT_GETTEMP: return 0;
  case XB_PKT_ADC1: return sizeof(XB_MSG_ADC);
  case XB_PKT_ADC2: return sizeof(XB_MSG_ADC);
  case XB_PKT_METEO1: return sizeof(XB_MSG_METEO1);
  case XB_PKT_METEO1_COEFFS: return sizeof(XB_MSG_METEO1_COEFFS);
  case XB_PKT_DBG_UINT8: return sizeof(XB_MSG_DBG_UINT8);
  case XB_PKT_DBG_CHR32: return sizeof(XB_MSG_DBG_CHR32);
  default: return 0;
  }
}
int _xb_tx_rdy(){
  switch(_xb_state){
  case XB_ST_IDLE: return 1; break;
  case XB_ST_RX  : return 1; break;
  default        : return 0;
    }  
}

// _xb_tick runs at 1kHz  when enabled
// processes xbus transmit
// hubs/routers run continously and manages unloading both
// transmit queues
/*
  __attribute__ ((volatile)) void _no_ack(){
}
*/
// manage bus message transmission
// unload queues and send messages
void _xb_hub_tick(){
  uint8 *src,addr,type,len;
  if (xq_tx_data_avail() && _xb_tx_rdy()){
    src = (uint8 *)xq_tx_head();
    addr = src[0];
    type = src[1];
    _xbus_transmit(addr,type,src+2);
    xq_tx_pop(NULL);
  }

#ifdef XB_UART
  if (xq_utx_data_avail() && uart_tx_rdy()){        
    src = (uint8 *)xq_utx_head();
    len = xq_utx_head_len();
    uart_tx_data(src,len);
    xq_utx_pop(NULL);

  }


#endif


}

#define TX_MAX_RETRIES 3
#define _WAIT_LIM 50
#define _ACK_DELAY 10
#define _TX_LIM 15
#define _HTICK  10

void _xb_tick(){
 
  if (_xb_tick_enable) {
    _xb_tick_count++;
  
    if (_xb_state == XB_ST_TX){
      if(_xb_tick_count ==  _TX_LIM){
	if (_xb_tx_count < TX_MAX_RETRIES){
	  _xb_tx_count++;
	  _xb_stats.tx_retries++;
	  _xb_stats.tx_no_eop++;
	  _xb_tick_count = 0;
	  _xbus_send_txbuff();
	} 
	else{
	  _xb_ps0_disable();
	  // _no_ack();
	  _xb_stats.tx_fails++;
	  _tx_status = XB_TX_ABORTED;
	  _xb_tick_count = 0;

	  if ( xbus_can_sleep())
	    _xbus_idle();
	  else
	    xb_receive_on();

	} 
      }
    }
    else if (_xb_state == XB_ST_ACKDELAY){
      if(_xb_tick_count ==  _ACK_DELAY){
	_xb_ps0_disable();
	_xb_state = XB_ST_ACK;
	_xb_tick_count = 0;
	_xb_tx_ack();
      }
    }
    else if(_xb_state == XB_ST_WAITACK){
      if(_xb_tick_count ==  _WAIT_LIM){
	if (_xb_tx_count < TX_MAX_RETRIES){
	  _xb_tx_count++;
	  _xb_stats.tx_retries++;
	  _xb_tick_count = 0;
	  _xbus_send_txbuff();
	} 
	else{
	  _xb_ps0_disable();
	  // _no_ack();
	  _xb_stats.tx_fails++;
	  _tx_status = XB_TX_NOACK;
	  _xb_tick_count = 0;

	  if ( xbus_can_sleep())
	    _xbus_idle();
	  else
	    xb_receive_on();




	}
      }      
    }
    else {
      _xb_ps0_disable();   
      _xb_tick_count = 0;
      _xb_stats.tick_err++;

    }

  }
  _xb_htick_count++;
  if (_xb_htick_count == _HTICK){
    _xb_htick_count = 0;
    _xb_hub_tick();

  }

#ifndef XB_HUB
  // turn off tick for periphs when not needed 
  if ( (_xb_tick_enable == 0))
    _xb_ps0_disable();

#endif
}


void burstwritten(){
  RSTAT = GetRF1ASTATB();
  __nop();
}



volatile int dummy;


uint8 _xb_is_ack(){
  if (_xb_rx_buff.hdr.msgid != _xb_tx_buff.hdr.msgid)
    return 0;
  if (_xb_rx_buff.hdr.source != _xb_tx_buff.dest)
    return 0;
  return 1;
}

XB_TX_STATUS _xb_check_ack(){

  if (_xb_rx_buff.hdr.type & XB_PKT_WAKEUP){
    _xb_can_sleep = 0;
  } else{
    
    _xb_can_sleep = 1;

  }

#ifndef XB_HUB
  if ((_xb_rx_buff.hdr.source == XB_HUBADDR) &&  _rtc_td_is_valid((TIMEDATE*)&_xb_rx_buff.td))  // update our clock if ack is from hub
    rtc_set((TIMEDATE *)&_xb_rx_buff.td);
#endif

  if (_xb_rx_buff.hdr.type & XB_PKT_ACK)
    return XB_TX_COMPLETED;

  if (_xb_rx_buff.hdr.type & XB_PKT_RETRY)
    return XB_TX_DEFERRED; 
  return XB_TX_BADACK;
}


static int xb_debug(int val);

XB_TX_STATUS tx_stat;


volatile int XBDBG;
volatile int XBDBGdumm;

static int xb_debug(int val){
  XBDBGdumm++;
  XBDBG = val;
}
uint8 _xb_q_buff[64];
int xbus_queue_msg(uint8 type,uint8 *xdata){
  int i;
  _xb_q_buff[0] = XB_HUBADDR;
  _xb_q_buff[1] = type;
  for ( i = 0 ; i < _xbus_msg_xdata_len( type) ; i++)
    _xb_q_buff[2+i] = xdata[i];
  
  xq_tx_push(_xb_q_buff,_xbus_msg_xdata_len( type)+2);
  xbus_start_tick();
  return 0;
}


XB_TX_STATUS _xbus_transmit(uint8 dest, uint8 type,uint8 *xdata){
  uint8 i,offs,xdlen,pktlen,*dptr;
  xb_receive_off();
  _xb_tx_count = 0; 
 
  xdlen = _xbus_msg_xdata_len( type);
  pktlen = 1 + sizeof(XB_MSG_HDR) + xdlen; // add 1 for addr byte
  offs = 2; // 0,1 reserved for length,addr
  _xb_tx_buff.dest = dest;
  _xb_tx_buff.hdr.type = type;
  _xb_tx_buff.hdr.msgid++;
  if (_xb_tx_buff.dest == XB_HUBADDR){
    _xb_tx_buff.hdr.rssi = HUBRSSI;
    _xb_tx_buff.hdr.lqi = HUBLQI;

  }
  else{
    _xb_tx_buff.hdr.rssi = 0;
    _xb_tx_buff.hdr.lqi = 0;

  }
    
  if(type < XB_PKT_NORMSTART){
    // fill in time for types >= 80h
    pktlen  += sizeof(XB_MSG_TIMEDATE);
    rtc_get((TIMEDATE *)(&_xb_tx_buff.td));
    offs += sizeof(TIMEDATE);
    dptr =(uint8 *)_xb_tx_buff.xdata;     
  }
  else{
    dptr = (uint8 *)&_xb_tx_buff.td;
  }
  _xb_tx_buff.pkt_len = pktlen;

  // copy xdata if required

  for (i = 0 ; i < xdlen ; i++)
    *(dptr + i) = *(xdata + i);
  // _xb_state = XB_ST_TX;
  _tx_status = XB_TX_BUSY;
  _xbus_send_txbuff();
  //RF1CTL1 = RF1AIFCTL1;


  //RF1CTL1 = RF1AIFCTL1;
  
  //RSTAT = GetRF1ASTATB();
  burstwritten();
  /*
  while ( _tx_status == XB_TX_BUSY){
    __delay_cycles(100);
  }
  return _tx_status;
  */
  return 0;
  //  return  _xb_tx_buff.hdr.msgid;
} 

// re-transmit txbuff

void wait_tx_rdy(){

  while(RfTxStat() & 0x80)
    __delay_cycles(100);
}

int  _xbus_send_txbuff(){
  // wait for radio to be ready
  //  wait_tx_rdy();


  _xb_state = XB_ST_TX;
  RF1AIES |= BIT9;                          
  RF1AIFG &= ~BIT9;                         // Clear pending interrupts
  RF1AIE |= BIT9;                           // Enable TX end-of-packet interrupt  
 
  // P1OUT |= 0x01; // turn LED on 

  RF1CTL1 = RF1AIFCTL1;
  _xb_tick_count = 0;
  //  _xb_ack_timer = 0;
  WriteBurstReg(RF_TXFIFOWR, (uint8 *)&_xb_tx_buff,_xb_tx_buff.pkt_len + 1);     

  Strobe( RF_STX );                         // Strobe STX  
  _xb_ps0_enable(_xb_tick);

  return 0;
 

}


XB_TX_STATUS xbus_despatch(uint8 dest, uint8 type,uint8 *xdata){
  do {
    __delay_cycles(1000);
  }while(_xb_tx_rdy() == 0);

  // try delivery
  _xbus_transmit(dest,type,xdata);
  // this is rubbish
  return XB_TX_COMPLETED;
  // return _xbus_main();

  
}


static unsigned int RF1AIVREG;

static XB_STATE dbst;
void dbg1(XB_STATE st){
  dbst = st;
}

void dbg_ack_txed(XB_STATE st){
  dbst = st;
}

void _chk_isr(int cnt,XB_STATE st,uint8 stat){
  

}
void _got_ack(){

}

// only hubs and routers  should do much here
void _xb_proc_ack(){
#if XB_UART
  switch (_xb_rx_buff.hdr.type & XB_PKT_CODEMASK){
  case XB_PKT_GETSTATS: _rx_queue_push(); break;
  case XB_PKT_GETTIME: _rx_queue_push(); break;
  case XB_PKT_PING: _rx_queue_push(); break;
  case XB_PKT_INFO: _rx_queue_push(); break;
  default:  break; 
  }  
#else
  switch (_xb_rx_buff.hdr.type & XB_PKT_CODEMASK){
  case XB_PKT_PING: _rx_queue_push(); break;
  case XB_PKT_INFO: _rx_queue_push(); break;
  default:  break; 
  }  
#endif
}


XB_STATE dbgst;
void    _dbg100(XB_STATE st){
}
void    _dbg101(XB_STATE st){
}
void mon_dbg(){
  __delay_cycles(1);
}


interrupt(CC1101_VECTOR) CC1101_ISR(void)
{

  XB_STATE xbst = _xb_state;
  int xbreceiving = _xb_receiving(xbst);
  int xbtransmitting = _xb_transmitting(xbst);
  int rx_ournet = 0;
  int rx_crcok = 0;
  _rf_isr_cnt++;
  //RSTAT = GetRF1ASTATB();
  // _chk_isr(_rf_isr_cnt,xbst,RSTAT);
  
  // switch(__even_in_range(RF1AIV,32))        // Prioritizing Radio Core Interrupt 
  RF1AIVREG = RF1AIV;
  //  switch(RF1AIV,32)        // Prioritizing Radio Core Interrupt 
  switch(RF1AIVREG)        // Prioritizing Radio Core Interrupt 
  {
    case  0: break;                         // No RF core interrupt pending                                            
    case  2: break;                         // RFIFG0 
    case  4: break;                         // RFIFG1
    case  6: break;                         // RFIFG2
    case  8: break;                         // RFIFG3
    case 10: break;                         // RFIFG4
    case 12: break;                         // RFIFG5
    case 14: break;                         // RFIFG6          
    case 16: break;                         // RFIFG7
    case 18: break;                         // RFIFG8
    case 20:                                // RFIFG9
      if(xbreceiving)			    // RX end of packet
      {
        if (xbst == XB_ST_IDLE){
          Strobe(RF_SIDLE);
          Strobe(RF_SFRX);// flush rx fifo
          //_dbg101(xbst);
          return;
        }
        // Read the length byte from the FIFO       
        rx_buffer_Length = ReadSingleReg( RXBYTES ); 
        ReadBurstReg(RF_RXFIFORD,(uint8 *) &_xb_rx_buff, rx_buffer_Length); 
        // Stop here to see contents of _xb_rx_buff
        __no_operation();      
        RFRXRSSI = *(((uint8 *)(&_xb_rx_buff)) +rx_buffer_Length-2);
	
        RFRXCSUM = *(((uint8 *)(&_xb_rx_buff)) +rx_buffer_Length-1);
#ifdef XB_MODE_SNIFFER
        // sniffer gets all packets        
          if (_rx_queue_full())
            _xb_stats.rx_overruns++;
          else{              
            _rx_queue_push();
            _xb_stats.rx_pkts++;    
          }
          xb_receive_on();          
#else
          // Check packet belongs to our network
          // Check the CRC results
          //if(xbst == XB_ST_WAITACK)
	   xb_debug(0x55);
          if(RFRXCSUM & CRC_OK){
            if ( _xb_rx_buff.hdr.netid == XB_NET){
                //P1OUT |= BIT0;                    // Toggle LED1             
                //dbg1(xbst);
#ifdef XB_MON_ID
	      mon_dbg();
	      if((_xb_rx_buff.hdr.source == XB_MON_ID) && (_xb_rx_buff.hdr.type == XB_MON_TYPE) && (_xb_mon_last_msgid != _xb_rx_buff.hdr.msgid)) {
		_xb_mon_last_msgid = _xb_rx_buff.hdr.msgid;
		_xb_stats.rx_pkts++;
		if (_rx_queue_full()){
	    
		  _xb_stats.rx_overruns++;
		}
		else { // pp

		  _rx_queue_push();
		  _xb_stats.rx_pkts++; 
		}

	      }
	      xb_receive_on();   
	      break;

#else		
		if(_xb_rx_buff.hdr.source == XB_HUBADDR){
		  HUBRSSI = RFRXRSSI;
		  HUBLQI = RFRXCSUM & 0x7f;
		}

                if(xbst == XB_ST_WAITACK)   { // check ack ok
                  if (!_xb_is_ack()) {
                    _xb_receive_enable();
                    return;
                  }
                  _tx_status = _xb_check_ack();
                  if((_tx_status == XB_TX_COMPLETED)){
		    
                    _xb_ps0_disable(); // stop tick

                    _xb_stats.tx_pkts++;
                    //_got_ack();
		    _xb_stats.txn[_xb_tx_count]++;
                    //                    P1OUT &= ~BIT0;   // turn off LED if ack ok
		    _xb_proc_ack(); // for hubs and routers
		    
		    if(xbus_can_sleep())
		      _xbus_idle();
		    else
		      xb_receive_on();
                    return;                    
                  }   
                  else {
                    return;
                    //break;  // let xb_tick re-tx
                  }
                }
                else if(xbst == XB_ST_RX) {   
                  if (_xb_rx_buff.hdr.type & XB_RESPONSE){
                    _xb_stats.rx_unexp_ack++;
                    Strobe( RF_SIDLE );                      
                    Strobe( RF_SRX );   
                    return;
                  }
		  _xb_ack_buff.hdr.type  = _xb_rx_buff.hdr.type & XB_PKT_CODEMASK;
		  rtc_get((TIMEDATE *)& _xb_ack_buff.td);  // send our timestamp in ack



                  // this is mainly for slaves
                  if (_rx_immediate_response()){ // some messages are replied automatically 
                    (*(_rx_immediate_response()))();  // execute responder
		    _xb_ack_buff.hdr.type |= XB_PKT_ACK;                  
		    _xb_stats.rx_pkts++;    

                  }
                  else { //h11
                    _xb_ack_buff.pkt_len=sizeof(XB_ACK_BUFF) - 1; // len field not included in length
		   
                   if (_rx_queue_full()){
	    
                      _xb_stats.rx_overruns++;
                      _xb_ack_buff.hdr.type |= XB_PKT_RETRY;                  
                    }
                    else { // pp

                      _rx_queue_push();
                      _xb_stats.rx_pkts++; 
		      _xb_ack_buff.hdr.type |= XB_PKT_ACK;                  
                    }
		  }
		  if(_xb_device_is_awake(_xb_rx_buff.hdr.source))
		    _xb_ack_buff.hdr.type |= XB_PKT_WAKEUP;		  
		  _xb_setup_ack();  // setup ack tx
                }
#endif
	    } //end  if netid = our net
            else {
              _xb_stats.rx_net_errs++;
              Strobe( RF_SIDLE );                      
              Strobe( RF_SRX );                      

            }

          } //end  if CRC OK
          else {  // CRC ERROR
            _xb_stats.rx_crc_errs++; 
             Strobe( RF_SIDLE );                      
	     Strobe( RF_SRX );                      

	     // xb_receive_on();
          }
          // xb_receive_on();
          //  Strobe( RF_SRX );                      
#endif

      }
      else if(xbtransmitting)		    // TX end of packet
      {
	// _dbg100(xbst);
        RF1AIE &= ~BIT9;                    // Disable TX end-of-packet interrupt
        //  _xb_state = XB_ST_IDLE;

#if 1
        // P3OUT &= ~BIT6;                     // Turn off LED after Transmit 
        if (xbst ==  XB_ST_TX){
          //RSTAT = GetRF1ASTATB();
          _xb_st_waitack();
        }
        else if(xbst ==  XB_ST_ACK){ 
          //dbg_ack_txed(xbst);
          //          P1OUT &= ~BIT0;                    // Toggle LED1 
          //          P1OUT ^= BIT0;                    // Toggle LED1 
          RF1AIE &= BIT9;                           // disable TX end-of-packet interrupt  

          _xb_stats.tx_acks++;
          // must be ack state
          // go back to receive mode
          Strobe( RF_SIDLE );
          Strobe( RF_SFTX  );    
          Strobe( RF_SNOP );

          xb_receive_on();
          __bis_SR_register_on_exit(GIE); 
          // _xb_state = XB_ST_IDLE;
        }else { // some cockup
	  _xb_stats.fatal++;
	  
	  
	}
        //        Strobe( RF_SRX );                      

        // xb_receive_on(); // desperate measures

#endif
      }

      // else while(1); 			    // trap - sometimes gets in here - 
      break;
    case 22: break;                         // RFIFG10
    case 24: break;                         // RFIFG11
    case 26: break;                         // RFIFG12
    case 28: break;                         // RFIFG13
    case 30: break;                         // RFIFG14
    case 32: break;                         // RFIFG15
  }  
  //  __bic_SR_register_on_exit(LPM3_bits);     
  //  xb_receive_on(); // desperate measures
  // Strobe( RF_SRX );                      

}

