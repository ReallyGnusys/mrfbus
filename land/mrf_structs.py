from ctypes import *


class MrfStruct(LittleEndianStructure):
    def fromstr(self, string):
        memmove(addressof(self), string, sizeof(self))
    def __len__(self):
        return sizeof(self)

    def attstr(self,att):
        if str(type(att)).find('c_ubyte_Array') > -1:  #FIXME! 
            atts = ""
            for i in att:
                if i != 0:
                    atts += "%c"%chr(i)
                else:
                    break
        else:
            atts = "%d"%int(att)
        return atts
    def __repr__(self):
        s = ''
        for field in self._fields_:
            att = getattr(self,field[0])

            atts = self.attstr(att)
            s += "%s %s\n"%(field[0],atts)
        return s
    def __eq__(self,other):
        for field in self._fields_:
            att = getattr(self,field[0])
            oatt = getattr(other,field[0])
            atts = self.attstr(att)
            oatts = self.attstr(oatt)
            if atts != oatts:
                print "cmp attname %s failed us %s other %s"%(field[0],atts,oatts)
                return False
        return True

    def __ne__(self,other):
        return not self.__eq__(other)

    def tbd_unmunge(self):
        print "mungeabletype is %s"%type(c_uint())
        for field in self._fields_:
            att = getattr(self,field[0])
            attype = field[1]
            print "got att %s  type %s"%(field[0],type(attype()))
            if type(attype()) == type(c_uint()):
                print "its for munging"
                nattr = att >> 16 + ((att & 0xffff) << 16)
                setattr(self,field[0],nattr)
        print repr(self)
    def load(self, bytes):
        fit = min(len(bytes), sizeof(self))
        memmove(addressof(self), bytes, fit)
    def dump(self):
        return buffer(self)[:]




# constants from somewhere..

MRFBUFFLEN = 128

# FIXME structs defined in mrf_sys_structs should be autogenerated here..

class PktHeader(MrfStruct):
    _fields_ = [
        ("length", c_uint8),
        ("hdest", c_uint8),
        ("netid", c_uint8),
        ("udest", c_uint8),
        ("type", c_uint8),
        ("hsrc", c_uint8),
        ("usrc", c_uint8),
        ("msgid", c_uint8)
    ]

class PktResp(MrfStruct):
    _fields_ = [
        ("type", c_uint8),
        ("msgid", c_uint8),
        ("rlen", c_uint8)
    ]
class PktDeviceInfo(MrfStruct):
    _fields_ = [
        ("dev_name", c_uint8*10),
        ("mrfid", c_uint8),
        ("netid", c_uint8),
        ("num_buffs", c_uint8),
        ("num_ifs", c_uint8)
    ]

class PktDeviceStatus(MrfStruct):
    _fields_ = [
        ("num_if", c_uint8),
        ("buffs_total", c_uint8),
        ("buffs_free", c_uint8),
        ("errors", c_uint8),
        ("tx_retries", c_uint16),
        ("pad2", c_uint16),
        ("rx_pkts", c_uint32),
        ("tx_pkts", c_uint32)
    ]

class PktSysInfo(MrfStruct):
    _fields_ = [
        ("mrfbus_version", c_uint8*40),
        ("build", c_uint8*8),
        ("num_cmds", c_uint8),
        ("modified", c_uint8)
    ]

class PktTimeDate(MrfStruct):
    _fields_ = [
        ("sec",c_uint8),
        ("min", c_uint8),
        ("hour", c_uint8),
        ("day", c_uint8),
        ("mon", c_uint8),
        ("year", c_uint8)
        ]
    def __repr__(self):
        return "%02d:%02d:%02d %d/%d/%d"%(self.hour,self.min,self.sec,self.day,self.mon,self.year+2000)

class PktCmdInfo(MrfStruct):
    _fields_ = [
        ("name",c_uint8*16),
        ("type", c_uint8),
        ("cflags", c_uint8),
        ("req_size", c_uint8),
        ("rsp_size", c_uint8)
        ]

class PktAppInfo(MrfStruct):
    _fields_ = [
        ("name", c_uint8*16),
        ("num_cmds", c_uint8)
    ]
class PktUint8(MrfStruct):
    _fields_ = [
        ("value", c_uint8)
    ]

class PktIfStats(MrfStruct):
    _fields_ = [
        ("rx_pkts", c_uint16),
        ("tx_pkts", c_uint16),
        ("tx_acks", c_uint16),
        ("tx_overruns", c_uint16),
        ("tx_retries", c_uint16),
        ("unexp_ack", c_uint8),
        ("alloc_err", c_uint8),
        ("st_err", c_uint8)
    ]

# FIXME should be able to generate core command set arg and return templates from C here
mrf_cmd_ack = 0
mrf_cmd_retry = 1
mrf_cmd_resp = 2
mrf_cmd_device_info = 3
mrf_cmd_device_status = 4
mrf_cmd_sys_info = 5
mrf_cmd_if_stats = 6
mrf_cmd_get_time = 7
mrf_cmd_set_time = 8
mrf_cmd_buff_state = 9
mrf_cmd_cmd_info = 10
mrf_cmd_app_info = 11
mrf_cmd_app_cmd_info = 12
mrf_cmd_test_1 = 13 
mrf_cmd_test_2 = 14
mrf_cmd_usr_resp = 15
MRF_NUM_SYS_CMDS = 16


## some app commands for the time being here.. ideally would be auto discovered codes

mrf_cmd_spi_read = 129

MrfSysCmds = {

    mrf_cmd_device_info :  {
        'name' : "DEVICE_INFO",
        'param': None,
        'resp': PktDeviceInfo
    },
    mrf_cmd_device_status :  {
        'name' : "DEVICE_STATUS",
        'param': None,
        'resp': PktDeviceStatus
    },
    mrf_cmd_sys_info :  {
        'name' : "SYS_INFO",
        'param': None,
        'resp': PktSysInfo
    },
    mrf_cmd_if_stats :  {
        'name' : "IF_STATS",
        'param': PktUint8,
        'resp': PktIfStats
    },
    mrf_cmd_get_time : {
        'name' : "GET_TIME",
        'param': None,
        'resp': PktTimeDate   
    },
    mrf_cmd_cmd_info: {
        'name' : "CMD_INFO",
        'param': PktUint8,
        'resp': PktCmdInfo
    },
    mrf_cmd_app_info :  {
        'name' : "APP_INFO",
        'param': None,
        'resp': PktAppInfo
    },
    mrf_cmd_app_cmd_info: {
        'name' : "APP_CMD_INFO",
        'param': PktUint8,
        'resp': PktCmdInfo
    },

    mrf_cmd_usr_resp : {
        'name' : "USR_RESP",
        'param': PktResp,
        'resp' : None        
    }
}
    
    




